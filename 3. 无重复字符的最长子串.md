# 题目: 《3_无重复字符的最长子串》

给定一个字符串，找出不含有重复字符的 最长子串 的长度。

示例：
```
给定 "abcabcbb" ，没有重复字符的最长子串是 "abc" ，那么长度就是3。

给定 "bbbbb" ，最长的子串就是 "b" ，长度是1。

给定 "pwwkew" ，最长子串是 "wke" ，长度是3。请注意答案必须是一个子串，"pwke" 是 子序列 而不是子串。
```
# 结果
![](https://note.youdao.com/yws/public/resource/f607475660fca65fe48eea10a2cffe46/xmlnote/F70CDE2AABF94C8FBD961CF9C756784F/8046)
# 代码
这是我的实现代码：
```c
int lengthOfLongestSubstring(char* s) {
    char *pf = s;
    char *pr = s;
    int length = 0;
    
    if(*s == '\0'){
        return 0;
    }
    
    while(*pf != '\0'){
        //updata status
        pr = s;
        while(pr < pf){
            if(*pr == *pf){
                length = ((pf-s) > length)?(pf-s):length;
                s = pr + 1;
                pr = s;
                break;
            }
            pr++;
        }
        pf++;
    }
    
    return length = ((pf-s) > length)?(pf-s):length;
}
```

# 赏析

>哎呀~ 真不好意思，我这次写的代码太牛逼了~ 超过了100%的用户（内心：哇啦啦啦~我果然牛逼！）

那我就自己~~赏析~~（复盘）一下自己吧！

刚开始写的时候就注意题目给的三种情况了，导致好多的边界条件都没有考虑到，然后是根据测试pattern报的bug来迭代改好的！

也就是说我的逻辑思维能力还是很欠缺的！！！

我进步的地方就是代码慢慢写得好看了，比较简洁了，不会动不动就一大堆的if else，以前我也说过，一大堆的if else其实就是自己逻辑思维没有捋清的缘故，因此慢慢捋慢慢地你的思路就清晰了，对应的你的代码就简洁了！

里面好多的小细节，个中体会还真的只有自己一步一步写才有体会，有些我已经忘了，下个题目我还是针对每一步产生的bug以及背后的原因来具体写写吧！（ps. 真忘了自己之前是怎么写bug的了~ ）

其中需要捋清的是：两个指针在字符串里面移动，满足一定的条件，实时更新最后输出两个指针的长度就是最大长度；

上面的思路中漏了一环，那就是假如我产生的最大长度在前部份呢？因此要加入一个length变量来记录全局最大的长度，保证不被冲掉。
